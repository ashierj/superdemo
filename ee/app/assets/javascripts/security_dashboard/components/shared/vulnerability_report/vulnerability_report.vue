<script>
import { PortalTarget } from 'portal-vue';
import { isEqual } from 'lodash';
import { GlCollapsibleListbox, GlPopover, GlLink, GlIcon, GlSprintf } from '@gitlab/ui';
import { VULNERABILITY_STATES } from 'ee/vulnerabilities/constants';
import {
  SEVERITY_LEVELS,
  REPORT_TYPES_WITH_MANUALLY_ADDED,
} from 'ee/security_dashboard/store/constants';
import { createAlert } from '~/alert';
import countsQuery from 'ee/security_dashboard/graphql/queries/vulnerability_severities_count.query.graphql';
import SummaryHighlights from 'ee/vue_shared/security_reports/components/summary_highlights.vue';
import UserCalloutDismisser from '~/vue_shared/components/user_callout_dismisser.vue';
import glFeatureFlagsMixin from '~/vue_shared/mixins/gl_feature_flags_mixin';
import { __, s__ } from '~/locale';
import { getIdFromGraphQLId } from '~/graphql_shared/utils';
import { scrollToElement, contentTop } from '~/lib/utils/common_utils';
import VulnerabilityCounts from './vulnerability_counts.vue';
import VulnerabilityListGraphql from './vulnerability_list_graphql.vue';
import VulnerabilityFilters from './vulnerability_filters.vue';
import { FILTERS } from './constants';

const GROUP_STATE = [
  { value: 'detected', text: VULNERABILITY_STATES.detected },
  { value: 'confirmed', text: VULNERABILITY_STATES.confirmed },
  { value: 'dismissed', text: VULNERABILITY_STATES.dismissed },
  { value: 'resolved', text: VULNERABILITY_STATES.resolved },
];

const GROUP_SEVERITY = [
  { value: 'critical', text: SEVERITY_LEVELS.critical },
  { value: 'high', text: SEVERITY_LEVELS.high },
  { value: 'medium', text: SEVERITY_LEVELS.medium },
  { value: 'low', text: SEVERITY_LEVELS.low },
  { value: 'info', text: SEVERITY_LEVELS.info },
  { value: 'unknown', text: SEVERITY_LEVELS.unknown },
];

const GROUP_TOOLS = Object.entries(REPORT_TYPES_WITH_MANUALLY_ADDED).map(([reportType, text]) => ({
  value: reportType,
  text: reportType === 'generic' ? __('Other') : text,
}));

export default {
  components: {
    VulnerabilityCounts,
    VulnerabilityListGraphql,
    VulnerabilityFilters,
    PortalTarget,
    SummaryHighlights,
    GlCollapsibleListbox,
    GlLink,
    GlIcon,
    GlPopover,
    GlSprintf,
    UserCalloutDismisser,
  },
  mixins: [glFeatureFlagsMixin()],
  inject: {
    fullPath: {
      default: '',
    },
    isGroupVulnerabilityReport: {
      default: false,
    },
    isProjectVulnerabilityReport: {
      default: false,
    },
    scanners: {
      default: [],
    },
  },
  props: {
    filterDropdowns: {
      type: Array,
      required: true,
    },
    fields: {
      type: Array,
      required: true,
    },
    filterFn: {
      type: Function,
      required: false,
      default: (filters) => filters,
    },
    // Whether this report is visible on the page or not. Intended to be used with tabs so that if
    // the tab that the report is in is not active, the vulnerabilities aren't fetched.
    isVisible: {
      type: Boolean,
      required: false,
      default: true,
    },
    showCounts: {
      type: Boolean,
      required: false,
      default: false,
    },
  },
  data() {
    const { expandedGroup, groupBy } = this.groupByQueryParams();

    return {
      expandedGroup,
      lastExpandedGroup: '',
      groupBy,
      groupCounts: {},
      graphqlFilters: undefined,
      showNewFeaturePopover: false,
    };
  },
  computed: {
    shouldShowProjectNamespace() {
      return this.filterDropdowns.includes(FILTERS.PROJECT);
    },
    shouldShowGroupByButton() {
      if (!this.isVisible) {
        return false;
      }

      if (
        this.isGroupVulnerabilityReport &&
        this.glFeatures.groupLevelVulnerabilityReportGrouping
      ) {
        return true;
      }

      return this.isProjectVulnerabilityReport;
    },
    groups() {
      if (!this.groupBy) {
        return [{ value: '' }];
      }

      const groups = {
        state: GROUP_STATE,
        severity: GROUP_SEVERITY,
        reportType: GROUP_TOOLS,
      }[this.groupBy];

      return this.filterGroupsBySelectedFilter(groups);
    },
    groupFilters() {
      if (!this.groupBy) {
        return {};
      }

      return this.formatGroupFilters(this.expandedGroup);
    },
  },
  watch: {
    groupBy(newValue) {
      this.resetPagination();
      this.updateQueryString({ groupBy: newValue, expanded: '' });

      if (!newValue) {
        this.expandedGroup = '';
      } else {
        this.loadCounts();
      }
    },
    graphqlFilters() {
      if (this.groupBy) {
        this.loadCounts();
      }
    },
    expandedGroup(newValue) {
      this.updateQueryString({ expanded: newValue });

      if (!newValue || newValue === this.lastExpandedGroup) {
        return;
      }

      this.resetPagination();
    },
  },
  mounted() {
    setTimeout(() => {
      this.showNewFeaturePopover = true;
    }, 1000);
  },
  methods: {
    filterGroupsBySelectedFilter(groups = []) {
      const filters = [...(this.graphqlFilters?.[this.groupBy] || [])];

      if (this.groupBy === 'state') {
        // When a dismissal reason is selected, the state filter does not contain
        // `DISMISSED` as a value. This workaround adds the `DISMISSED` item to the
        // cloned array.
        if (this.graphqlFilters?.dismissalReason?.length) {
          filters.push('DISMISSED');
        }
      } else if (this.groupBy === 'reportType') {
        const reportTypes = new Set();

        // :project_tool_filter_with_scanner_name turned off
        if (this.scanners?.length > 0 && this.graphqlFilters?.scannerId) {
          const scannerIds = (this.graphqlFilters?.scannerId || []).map(getIdFromGraphQLId);
          const scanners = [...this.scanners, { id: null, report_type: 'GENERIC' }];

          scanners.forEach(({ id, report_type }) => {
            if (scannerIds.includes(id)) {
              reportTypes.add(report_type);
            }
          });
        }
        // :project_tool_filter_with_scanner_name turned on
        else if (this.graphqlFilters?.scanner) {
          const scanners = [
            ...this.scanners,
            { external_id: 'gitlab-manual-vulnerability-report', report_type: 'GENERIC' },
          ];

          scanners.forEach(({ external_id, report_type }) => {
            if (this.graphqlFilters.scanner.includes(external_id)) {
              reportTypes.add(report_type);
            }
          });
        }

        filters.push(...reportTypes);
      }

      return filters.length > 0
        ? groups.filter(({ value }) => filters.includes(value.toUpperCase()))
        : groups;
    },
    groupByQueryParams() {
      let { groupBy = '', expanded: expandedGroup = '' } = this.$route.query;

      if (!this.groups) {
        return { groupBy, expandedGroup };
      }

      // Validate query parameters and fix it if invalid
      if (groupBy && !this.$options.groupByOptions.some(({ value }) => value === groupBy)) {
        groupBy = '';
        this.updateQueryString({ groupBy: undefined }, 'replace');
      }

      if (expandedGroup && !this.groups[groupBy]?.some(({ value }) => value === expandedGroup)) {
        expandedGroup = '';
        this.updateQueryString({ expanded: undefined }, 'replace');
      }

      return { groupBy, expandedGroup };
    },
    updateQueryString(query, method = 'push') {
      const newQuery = { ...this.$route.query, ...query };

      // Anything that has an empty value, like '' or undefined, will be stripped
      // out to make sure we're not including empty query parameters in the URL.
      // In other words, this prevents query strings like: ?groupBy=&expanded=
      Object.keys(newQuery).forEach((key) => {
        if (!newQuery[key]) {
          delete newQuery[key];
        }
      });

      if (!isEqual(newQuery, this.$route.query)) {
        this.$router[method]({ query: newQuery });
      }
    },

    // Reset before and after query parameters when an expanded group changes
    resetPagination() {
      if (this.$route?.query.before || this.$route?.query.after) {
        this.updateQueryString({ before: undefined, after: undefined }, 'replace');
      }
    },

    formatGroupFilters(expandedGroup) {
      const isDismissedTab = expandedGroup === 'dismissed';
      const isStateGroup = this.groupBy === 'state';
      const hasDismissalReasons = this.graphqlFilters?.dismissalReason?.length > 0;
      const dismissalReason = this.graphqlFilters?.dismissalReason;

      // Special case:
      // state => DISMISSED means we're requesting all dismissed findings.
      // However, when dismissalReason is specified, we need to empty the `state`
      // and pass just dimissal reasons.
      if (isDismissedTab && hasDismissalReasons) {
        return { state: [], dismissalReason };
      }

      return {
        [this.groupBy]: [expandedGroup.toUpperCase()],
        // When a group other than `dismissed` is selected, since we want to display
        // only relevant findings to that group (e.g. detected), we need to empty the
        // dismissalReason array.
        dismissalReason: isStateGroup ? [] : dismissalReason,
      };
    },
    updateGraphqlFilters(graphqlFilters) {
      this.graphqlFilters = this.filterFn(graphqlFilters);
    },
    emitCountsChanged(counts) {
      this.$emit('counts-changed', counts);
    },
    scrollToTopOfList() {
      const { vulnerabilityListTop } = this.$refs;
      // Only scroll to the top of the vulnerability list if it's above and outside the main content
      // area (the space below the static page header).
      if (vulnerabilityListTop.getBoundingClientRect().top < contentTop()) {
        scrollToElement(vulnerabilityListTop);
      }
    },
    toggleExpandedGroup(value) {
      if (this.expandedGroup) {
        this.lastExpandedGroup = this.expandedGroup;
      }

      this.expandedGroup = this.expandedGroup === value ? '' : value;
    },
    computeShowSingleSeverityProp(group) {
      if (this.groupBy !== 'severity') {
        return undefined;
      }

      return group;
    },
    loadCounts() {
      this.groups
        .filter(({ value }) => value)
        .forEach(({ value }) => {
          const queryName = `groupCounts.${value}`;
          const variables = {
            fullPath: this.fullPath,
            isProject: this.isProjectVulnerabilityReport,
            isGroup: this.isGroupVulnerabilityReport,
            isInstance: false,
            ...this.graphqlFilters,
            ...this.formatGroupFilters(value),
          };

          if (this.$apollo.queries[queryName]) {
            this.$apollo.queries[queryName].setVariables(variables);
            return;
          }

          this.$apollo.addSmartQuery(queryName, {
            query: countsQuery,
            errorPolicy: 'none',
            variables() {
              return variables;
            },
            update(data) {
              const level = this.isProjectVulnerabilityReport ? 'project' : 'group';

              this.$set(this.groupCounts, value, data[level]?.vulnerabilitySeveritiesCount);
              return data[level]?.vulnerabilitySeveritiesCount;
            },
            error() {
              createAlert({
                message: s__(
                  'SecurityReports|Error fetching the vulnerability counts. Please check your network connection and try again.',
                ),
              });
            },
          });
        });
    },
  },
  portalName: 'vulnerability-report-sticky',
  groupByOptions: [
    { value: '', text: __('None') },
    { value: 'state', text: __('Status') },
    { value: 'severity', text: __('Severity') },
    { value: 'reportType', text: __('Tool') },
  ],
  i18n: {
    groupByNewFeatureTitle: s__('SecurityReports|New feature: Grouping'),
    groupByNewFeatureContent: s__(
      'SecurityReports|Group your vulnerabilities by one of the provided categories. Leave feedback or suggestions in %{feedbackIssueStart}this issue%{feedbackIssueEnd}.',
    ),
  },
};
</script>

<template>
  <div>
    <vulnerability-counts
      v-if="showCounts"
      class="gl-mb-7"
      :filters="graphqlFilters"
      @counts-changed="emitCountsChanged"
    />

    <div ref="vulnerabilityListTop" data-testid="vulnerability-list-top"></div>

    <div class="security-dashboard-filters gl-bg-white">
      <vulnerability-filters :filters="filterDropdowns" @filters-changed="updateGraphqlFilters" />
      <div
        v-if="shouldShowGroupByButton"
        class="gl-p-5 gl-bg-gray-10 gl-border-b-1 gl-border-b-solid gl-border-b-gray-100"
      >
        <div ref="groupByContainer" class="gl-display-inline-flex gl-align-items-center">
          <label for="group-by" class="gl-m-0">{{ __('Group by:') }}</label>
          <gl-collapsible-listbox
            id="group-by"
            v-model="groupBy"
            category="tertiary"
            class="gl-ml-2"
            :items="$options.groupByOptions"
          />
        </div>
        <user-callout-dismisser
          v-if="showNewFeaturePopover"
          ref="calloutDismisser"
          feature-name="vulnerability_report_grouping"
        >
          <template #default="{ dismiss, shouldShowCallout }">
            <gl-popover
              :show="shouldShowCallout"
              :title="$options.i18n.groupByNewFeatureTitle"
              :target="$refs.groupByContainer"
              triggers="manual"
              placement="top"
              show-close-button
              data-testid="group-by-new-feature"
              @close-button-clicked="dismiss"
            >
              <gl-sprintf :message="$options.i18n.groupByNewFeatureContent">
                <template #feedbackIssue="{ content }">
                  <gl-link
                    href="https://gitlab.com/gitlab-org/gitlab/-/issues/427631"
                    class="gl-font-sm"
                    >{{ content }}</gl-link
                  >
                </template>
              </gl-sprintf>
            </gl-popover>
          </template>
        </user-callout-dismisser>
      </div>
      <portal-target v-if="isVisible" :name="$options.portalName" />
    </div>

    <template v-if="isVisible">
      <div v-for="group in groups" :key="group.value">
        <div
          v-if="group.text"
          class="gl-p-5 gl-bg-gray-10 gl-border-b-1 gl-border-b-solid gl-border-b-gray-100 gl-display-flex gl-align-center"
          :data-testid="`vulnerability-list-group-header-${group.value}`"
        >
          <gl-link
            href="#"
            class="gl-text-body"
            :data-testid="`vulnerability-list-group-link-${group.value}`"
            @click="toggleExpandedGroup(group.value)"
          >
            <gl-icon
              name="chevron-right"
              class="gl-mr-2 gl-transition-medium"
              :class="{ 'gl-rotate-90': expandedGroup === group.value }"
            /><strong>{{ group.text }}</strong></gl-link
          >
          <summary-highlights
            v-if="groupCounts[group.value]"
            :data-testid="`summary-highlights-${group.value}`"
            class="gl-ml-3"
            :show-single-severity="computeShowSingleSeverityProp(group.value)"
            :highlights="groupCounts[group.value]"
          />
        </div>
        <vulnerability-list-graphql
          v-if="expandedGroup === group.value"
          :class="{ 'has-group-by': shouldShowGroupByButton, 'gl-mb-6': Boolean(groupBy) }"
          :fields="fields"
          :filters="graphqlFilters"
          :report-group-filters="groupFilters"
          :show-project-namespace="shouldShowProjectNamespace"
          :portal-name="$options.portalName"
          @vulnerability-clicked="$emit('vulnerability-clicked', $event)"
          @query-variables-changed="scrollToTopOfList"
        />
      </div>
    </template>
  </div>
</template>
