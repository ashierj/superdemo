# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    class AdvisoryScanner
      # Scans eligible projects that contain software components affected
      # by an advisory. If affected, it creates new vulnerabilities in the
      # project.
      #
      # @param advisory [PackageMetadata::Advisory] advisory
      # @param global [boolean] When true, scan all projects including those
      #                         where Continuous Vulnerability Scanning isn't enabled.
      def self.scan_projects_for(advisory, global:)
        new(advisory, global: global).execute
      end

      # Create a new advisory scanner instance.
      #
      # @param advisory [PackageMetadata::Advisory] advisory
      # @param global [boolean] When true, scan all projects including those
      #                         where Continuous Vulnerability Scanning isn't enabled.
      #
      # @return [Gitlab::VulnerabilityScanning::AdvisoryScanner]
      def initialize(advisory, global:)
        @advisory = advisory
        @global = global
        @possibly_affected_sbom_occurrences_count = 0
        @known_affected_sbom_occurrences_count = 0
        @possibly_affected_projects = {}
        @known_affected_projects = {}
      end

      def execute
        return if global && !Feature.enabled?(:global_dependency_scanning_on_advisory_ingestion)

        start_time = Time.current.iso8601

        advisory.affected_packages.each do |affected_package|
          advisory_data_object = vulnerability_scanning_advisory(solution: affected_package.solution)
          purl_type = affected_package.purl_type
          package_name = affected_package.package_name

          ::Sbom::PossiblyAffectedOccurrencesFinder.new(
            purl_type: purl_type,
            package_name: package_name,
            global: global
          ).execute_in_batches do |batch|
            bulk_vulnerability_ingestion(affected_package, advisory_data_object, batch)
          end
        end

        Gitlab::VulnerabilityScanning::TrackCvsService.new(
          advisory: advisory,
          start_time: start_time,
          end_time: Time.current.iso8601,
          counts: {
            possibly_affected_projects: possibly_affected_projects_count,
            known_affected_projects: known_affected_projects_count,
            possibly_affected_sbom_occurrences: possibly_affected_sbom_occurrences_count,
            known_affected_sbom_occurrences: known_affected_sbom_occurrences_count
          },
          global: global
        ).execute
      end

      private

      attr_reader :advisory, :global, :possibly_affected_sbom_occurrences_count, :known_affected_sbom_occurrences_count

      def occurrence_is_affected?(purl_type:, range:, version:)
        Gitlab::VulnerabilityScanning::DependencyScanning::AffectedVersionRangeMatcher.new(
          purl_type: purl_type, range: range, version: version).affected?
      end

      def vulnerability_scanning_advisory(solution:)
        Gitlab::VulnerabilityScanning::Advisory.new(
          xid: advisory.advisory_xid,
          title: advisory.title,
          description: advisory.description,
          identifiers: advisory.identifiers,
          urls: advisory.urls,
          cvss_v2: advisory.cvss_v2,
          cvss_v3: advisory.cvss_v3,
          solution: solution
        )
      end

      def bulk_vulnerability_ingestion(affected_package, advisory_data_object, occurrences_batch)
        affected_components = occurrences_batch.filter_map do |occurrence|
          count_possibly_affected_sbom_occurrence(occurrence)

          next unless occurrence_is_affected?(
            purl_type: affected_package.purl_type,
            range: affected_package.affected_range,
            version: occurrence.version)

          count_known_affected_sbom_occurrence(occurrence)

          Gitlab::VulnerabilityScanning::PossiblyAffectedComponent
            .from_sbom_occurrence(occurrence)
        end

        return if affected_components.empty?

        create_vulnerabilities(advisory_data_object, affected_components)
      end

      def create_vulnerabilities(advisory, affected_components)
        response = ::Security::VulnerabilityScanning::CreateVulnerabilityService.execute(
          advisory: advisory, affected_components: affected_components)

        project_ids_with_upsert = response.payload[:project_ids_with_upsert]
        project_ids_with_error = response.payload[:project_ids_with_error]
        if response.success?
          log_success(project_ids_with_upsert: project_ids_with_upsert, project_ids_with_error: project_ids_with_error)
        else
          log_error(response.payload[:error], project_ids_with_upsert: project_ids_with_upsert,
            project_ids_with_error: project_ids_with_error)
        end
      end

      def count_possibly_affected_sbom_occurrence(occurrence)
        @possibly_affected_sbom_occurrences_count += 1
        @possibly_affected_projects[occurrence.project.id] = true
      end

      def count_known_affected_sbom_occurrence(occurrence)
        @known_affected_sbom_occurrences_count += 1
        @known_affected_projects[occurrence.project.id] = true
      end

      def possibly_affected_projects_count
        @possibly_affected_projects.keys.size
      end

      def known_affected_projects_count
        @known_affected_projects.keys.size
      end

      def log_success(project_ids_with_upsert:, project_ids_with_error:)
        Gitlab::AppJsonLogger.debug(message: "Successfully created vulnerabilities on advisory ingestion",
          project_ids_with_upsert: project_ids_with_upsert, project_ids_with_error: project_ids_with_error,
          source_xid: advisory.source_xid, advisory_xid: advisory.advisory_xid)
      end

      def log_error(error, project_ids_with_upsert:, project_ids_with_error:)
        Gitlab::AppJsonLogger.error(message: "Failed to create vulnerabilities on advisory ingestion", error: error,
          project_ids_with_upsert: project_ids_with_upsert, project_ids_with_error: project_ids_with_error,
          source_xid: advisory.source_xid, advisory_xid: advisory.advisory_xid)
      end
    end
  end
end
