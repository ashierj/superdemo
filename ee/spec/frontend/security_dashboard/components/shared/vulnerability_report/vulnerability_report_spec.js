import Vue, { nextTick } from 'vue';
import VueApollo from 'vue-apollo';
import VueRouter from 'vue-router';
import { PortalTarget } from 'portal-vue';
import { GlCollapsibleListbox, GlLink, GlIcon, GlPopover } from '@gitlab/ui';
import createMockApollo from 'helpers/mock_apollo_helper';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import waitForPromises from 'helpers/wait_for_promises';
import { makeMockUserCalloutDismisser } from 'helpers/mock_user_callout_dismisser';
import { VULNERABILITY_STATES } from 'ee/vulnerabilities/constants';
import countsQuery from 'ee/security_dashboard/graphql/queries/vulnerability_severities_count.query.graphql';
import {
  DASHBOARD_TYPES,
  SEVERITY_LEVELS,
  REPORT_TYPES_WITH_MANUALLY_ADDED,
} from 'ee/security_dashboard/store/constants';
import VulnerabilityReport from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_report.vue';
import projectVulnerabilitiesQuery from 'ee/security_dashboard/graphql/queries/project_vulnerabilities.query.graphql';
import VulnerabilityCounts from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_counts.vue';
import VulnerabilityFilters from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_filters.vue';
import VulnerabilityListGraphql from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_list_graphql.vue';
import { FILTER_PRESETS } from 'ee/security_dashboard/components/shared/vulnerability_report/constants';
import * as CommonUtils from '~/lib/utils/common_utils';

Vue.use(VueApollo);
Vue.use(VueRouter);

describe('Vulnerability report component', () => {
  let wrapper;
  let router;
  let userCalloutDismissSpy;

  const createWrapper = ({
    apolloProvider,
    query = projectVulnerabilitiesQuery,
    fields = [],
    filterDropdowns = [],
    isVisible = true,
    showCounts = true,
    fullPath,
    filterFn,
    scanners,
    isGroupVulnerabilityReport,
    isProjectVulnerabilityReport = true,
    glFeatures,
    shouldShowCallout = false,
  } = {}) => {
    router = new VueRouter({
      base: '/vulnerability-report',
      mode: 'history',
    });

    userCalloutDismissSpy = jest.fn();

    wrapper = shallowMountExtended(VulnerabilityReport, {
      apolloProvider,
      router,
      provide: {
        isGroupVulnerabilityReport,
        isProjectVulnerabilityReport,
        fullPath,
        scanners,
        glFeatures,
      },
      propsData: {
        query,
        fields,
        filterDropdowns,
        isVisible,
        showCounts,
        filterFn,
      },
      stubs: {
        GlCollapsibleListbox,
        UserCalloutDismisser: makeMockUserCalloutDismisser({
          dismiss: userCalloutDismissSpy,
          shouldShowCallout,
        }),
      },
    });
  };

  const findCounts = () => wrapper.findComponent(VulnerabilityCounts);
  const findPortalTarget = () => wrapper.findComponent(PortalTarget);
  const findFilters = () => wrapper.findComponent(VulnerabilityFilters);
  const findList = () => wrapper.findComponent(VulnerabilityListGraphql);
  const findListTopDiv = () => wrapper.findByTestId('vulnerability-list-top');
  const findGroupByButton = () => wrapper.findComponent(GlCollapsibleListbox);

  describe('counts', () => {
    it.each([true, false])('shows/hides the counts', (showCounts) => {
      createWrapper({ showCounts });

      expect(findCounts().exists()).toBe(showCounts);
    });

    it('bubbles up the counts-changed event', () => {
      createWrapper();
      const data = {};
      findCounts().vm.$emit('counts-changed', data);

      expect(wrapper.emitted('counts-changed')[0][0]).toBe(data);
    });
  });

  describe('portal target', () => {
    it.each([true, false])('shows/hides the portal', (isVisible) => {
      createWrapper({ isVisible });

      expect(findPortalTarget().exists()).toBe(isVisible);
    });

    it('uses the same portal name as the vulnerability list', () => {
      createWrapper();

      expect(findPortalTarget().props('name')).toBe(findList().props('portalName'));
    });
  });

  describe('filters', () => {
    it('gets the expected filters prop', () => {
      const filterDropdowns = [];
      createWrapper({ filterDropdowns });

      expect(findFilters().props('filters')).toBe(filterDropdowns);
    });

    it('calls the filter transform function when the filters are changed', async () => {
      const fnData = { b: 3, d: 4 };
      const filterFn = jest.fn().mockImplementation(() => fnData);
      createWrapper({ filterFn });
      const data = { a: 1, b: 2 };
      findFilters().vm.$emit('filters-changed', data);
      await nextTick();

      // We test that the filter function is called with the data emitted by VulnerabilityFilters.
      // Then we test that the list gets the value returned by filterFn (the transformed value).
      expect(filterFn).toHaveBeenCalledTimes(1);
      expect(filterFn).toHaveBeenCalledWith(data);
      expect(findList().props('filters')).toBe(fnData);
    });

    it('passes the filter data to the counts and list when the filters are changed', async () => {
      createWrapper();
      const data = {};
      findFilters().vm.$emit('filters-changed', data);
      await nextTick();

      expect(findCounts().props('filters')).toBe(data);
      expect(findList().props('filters')).toBe(data);
    });
  });

  describe('vulnerability list', () => {
    it('gets the expected props', () => {
      const fields = [];
      createWrapper({ fields });

      expect(findList().props('fields')).toBe(fields);
    });

    it.each`
      filterDropdowns                       | expected
      ${FILTER_PRESETS.DEVELOPMENT}         | ${true}
      ${FILTER_PRESETS.DEVELOPMENT_PROJECT} | ${false}
      ${FILTER_PRESETS.OPERATIONAL}         | ${true}
      ${FILTER_PRESETS.OPERATIONAL_PROJECT} | ${false}
    `('gets the expected showProjectNamespace prop', ({ filterDropdowns, expected }) => {
      createWrapper({ filterDropdowns });

      expect(findList().props('showProjectNamespace')).toBe(expected);
    });

    it.each([true, false])('is shown/hidden when the isVisible prop is %s', (isVisible) => {
      createWrapper({ isVisible });

      expect(findList().exists()).toBe(isVisible);
    });

    it('bubbles up the vulnerability-clicked event', () => {
      createWrapper();
      const data = {};
      findList().vm.$emit('vulnerability-clicked', data);

      expect(wrapper.emitted('vulnerability-clicked')[0][0]).toBe(data);
    });
  });

  describe('scroll to top behavior', () => {
    beforeEach(() => {
      createWrapper();
    });

    it('has the target div to scroll to', () => {
      expect(findListTopDiv().exists()).toBe(true);
    });

    it('scrolls to the top of the list if the top of the list is below the viewport', () => {
      const div = findListTopDiv().element;
      jest.spyOn(div, 'getBoundingClientRect').mockReturnValue({ top: -51 });
      jest.spyOn(CommonUtils, 'contentTop').mockReturnValue(50);
      const spy = jest.spyOn(CommonUtils, 'scrollToElement');
      findList().vm.$emit('query-variables-changed');

      expect(spy).toHaveBeenCalledTimes(1);
      expect(spy).toHaveBeenCalledWith(div);
    });

    it('does not scroll to the top of the list if the top of the list is above the viewport', () => {
      const div = findListTopDiv().element;
      jest.spyOn(div, 'getBoundingClientRect').mockReturnValue({ top: 46 });
      jest.spyOn(CommonUtils, 'contentTop').mockReturnValue(45);
      const spy = jest.spyOn(CommonUtils, 'scrollToElement');
      findList().vm.$emit('query-variables-changed');

      expect(spy).not.toHaveBeenCalled();
    });
  });

  describe.each`
    dashboardType
    ${DASHBOARD_TYPES.PROJECT}
    ${DASHBOARD_TYPES.GROUP}
  `('group by: $dashboardType', ({ dashboardType }) => {
    const counts = { critical: 1, high: 2, medium: 5, low: 4, info: 3, unknown: 6 };

    const getCountsRequestHandler = ({ data = counts } = {}) => {
      return jest.fn().mockResolvedValue({
        data: {
          [dashboardType]: {
            id: '1',
            vulnerabilitySeveritiesCount: { __typename: 'VulnerabilitySeveritiesCount', ...data },
          },
        },
      });
    };

    const findNewFeaturePopover = () => wrapper.findComponent(GlPopover);
    const findSummaryHighlights = (groupValue) =>
      wrapper.findByTestId(`summary-highlights-${groupValue}`);
    const findGroupHeader = (groupValue) =>
      wrapper.findByTestId(`vulnerability-list-group-header-${groupValue}`);
    const findGroupHeaderLink = (groupValue) =>
      wrapper.findByTestId(`vulnerability-list-group-link-${groupValue}`);

    const createWrapperWithFilters = async ({
      shouldShowCallout,
      scanners,
      filters = {
        state: [],
        severity: [],
        dismissalReason: [],
      },
    } = {}) => {
      createWrapper({
        apolloProvider: createMockApollo([[countsQuery, getCountsRequestHandler()]]),
        isProjectVulnerabilityReport: dashboardType === DASHBOARD_TYPES.PROJECT,
        isGroupVulnerabilityReport: dashboardType === DASHBOARD_TYPES.GROUP,
        fullPath: 'gitlab-org/gitlab',
        shouldShowCallout,
        scanners,
        glFeatures:
          DASHBOARD_TYPES.GROUP === dashboardType
            ? {
                groupLevelVulnerabilityReportGrouping: true,
              }
            : {},
      });

      // Reset filters
      await findFilters().vm.$emit('filters-changed', filters);
    };

    const selectGroupByItem = async (value) => {
      const listbox = findGroupByButton();
      listbox.vm.$emit('shown');
      listbox.vm.$emit('select', value);

      await waitForPromises();
    };

    it('displays the group by label', () => {
      createWrapperWithFilters();
      expect(wrapper.findByText('Group by:').exists()).toBe(true);
    });

    it('passes the correct items', () => {
      createWrapperWithFilters();
      expect(findGroupByButton().props('items')).toEqual([
        { value: '', text: 'None' },
        { value: 'state', text: 'Status' },
        { value: 'severity', text: 'Severity' },
        { value: 'reportType', text: 'Tool' },
      ]);
    });

    it('filters report types correctly when :project_tool_filter_with_scanner_name is off', async () => {
      await createWrapperWithFilters({
        scanners: [
          {
            id: 234,
            report_type: 'SAST',
            external_id: 'eslint',
          },
          {
            id: 235,
            report_type: 'SAST',
            external_id: 'find_sec_bugs',
          },
          {
            id: 236,
            report_type: 'DAST',
            external_id: 'some_dast_scanner',
          },
        ],
        filters: {
          scannerId: [
            'gid://gitlab/Vulnerabilities:Scanner/234',
            'gid://gitlab/Vulnerabilities:Scanner/235',
            'gid://gitlab/Vulnerabilities:Scanner/null',
          ],
        },
      });

      // Change view: Select status group
      selectGroupByItem('reportType');
      await nextTick();

      expect(findGroupHeaderLink('generic').exists()).toBe(true);
      expect(findGroupHeaderLink('sast').exists()).toBe(true);
      expect(findGroupHeaderLink('dast').exists()).toBe(false);
    });

    it('filters report types correctly when :project_tool_filter_with_scanner_name is on', async () => {
      await createWrapperWithFilters({
        scanners: [
          {
            id: 234,
            report_type: 'SAST',
            external_id: 'eslint',
          },
          {
            id: 235,
            report_type: 'SAST',
            external_id: 'find_sec_bugs',
          },
          {
            id: 236,
            report_type: 'DAST',
            external_id: 'some_dast_scanner',
          },
        ],
        filters: {
          scanner: ['gitlab-manual-vulnerability-report', 'eslint', 'find_sec_bugs'],
        },
      });

      // Change view: Select status group
      selectGroupByItem('reportType');
      await nextTick();

      expect(findGroupHeaderLink('generic').exists()).toBe(true);
      expect(findGroupHeaderLink('sast').exists()).toBe(true);
      expect(findGroupHeaderLink('dast').exists()).toBe(false);
    });

    it('behaves correctly when dismissalReason is specified', async () => {
      await createWrapperWithFilters({
        filters: {
          state: ['RESOLVED'],
          dismissalReason: ['ACCEPTABLE_RISK'],
        },
      });

      // Default view: No group selected yet
      expect(findList().props('reportGroupFilters')).toEqual({});

      // Change view: Select status group
      selectGroupByItem('state');
      await nextTick();

      // When a filter different than DISMISSED is clicked, we need to reset
      // dismissal reason.
      await findGroupHeaderLink('resolved').vm.$emit('click');

      expect(findList().props('reportGroupFilters')).toEqual({
        dismissalReason: [],
        state: ['RESOLVED'],
      });

      // When dismissed is clicked, we need to empty the `state` and
      // pass the dismissalReason.
      await findGroupHeaderLink('dismissed').vm.$emit('click');

      expect(findList().props('reportGroupFilters')).toEqual({
        dismissalReason: ['ACCEPTABLE_RISK'],
        state: [],
      });
    });

    it('displays the default view when group by is switched back to none', async () => {
      await createWrapperWithFilters();
      selectGroupByItem('severity');
      await nextTick();

      // We should see the vulnerability report
      await findGroupHeaderLink('critical').vm.$emit('click');

      expect(findList().exists()).toBe(true);

      // Switch back to none
      selectGroupByItem('');
      await nextTick();

      // We should still see the vulnerability report
      expect(findList().exists()).toBe(true);

      // And we should not see groups
      expect(findGroupHeader('critical').exists()).toBe(false);
    });

    it('refetches group counts when the same group is re-selected', async () => {
      await createWrapperWithFilters();
      await selectGroupByItem('state');

      expect(findSummaryHighlights('confirmed').props('highlights')).toEqual({
        ...counts,
        __typename: 'VulnerabilitySeveritiesCount',
      });

      await selectGroupByItem('severity');

      expect(findSummaryHighlights('critical').props('highlights')).toEqual({
        ...counts,
        __typename: 'VulnerabilitySeveritiesCount',
      });

      await selectGroupByItem('state');

      expect(findSummaryHighlights('confirmed').props('highlights')).toEqual({
        ...counts,
        __typename: 'VulnerabilitySeveritiesCount',
      });

      expect(findSummaryHighlights('critical').exists()).toBe(false);
    });

    it('resets pagination when group changes', async () => {
      await createWrapperWithFilters();
      await selectGroupByItem('state');

      const spy = jest.spyOn(router, 'replace');

      // This call should avoid calling the push method because we have no before/after params set
      findGroupHeader('detected').findComponent(GlLink).vm.$emit('click');
      await nextTick();

      expect(spy).not.toHaveBeenCalled();

      // Now that we have these parameters, the spy should be called.
      router.currentRoute.query.before = 'before-id';
      router.currentRoute.query.after = 'after-id';

      findGroupHeader('confirmed').findComponent(GlLink).vm.$emit('click');
      await nextTick();

      expect(router.currentRoute.query.before).toBeUndefined();
      expect(router.currentRoute.query.after).toBeUndefined();
    });

    it('does not reset pagination when a group is collapsed', async () => {
      await createWrapperWithFilters();
      await selectGroupByItem('state');

      const spy = jest.spyOn(router, 'replace');

      // This call should avoid calling the push method because we have no before/after params set
      findGroupHeader('detected').findComponent(GlLink).vm.$emit('click');
      await nextTick();

      expect(spy).not.toHaveBeenCalled();

      // Now that we have these parameters, the spy should be called.
      router.currentRoute.query.before = 'before-id';
      router.currentRoute.query.after = 'after-id';

      findGroupHeader('detected').findComponent(GlLink).vm.$emit('click');
      await nextTick();

      expect(spy).not.toHaveBeenCalled();
    });

    describe('new feature popup', () => {
      beforeEach(async () => {
        await createWrapperWithFilters({ shouldShowCallout: true });
        jest.runAllTimers();
        await nextTick();
      });

      it('should show the new feature popup', () => {
        expect(findNewFeaturePopover().exists()).toBe(true);
      });

      it('should handle closing the feature popup', async () => {
        findNewFeaturePopover().vm.$emit('close-button-clicked');
        await nextTick();
        expect(userCalloutDismissSpy).toHaveBeenCalled();
      });
    });

    describe.each`
      group           | values                                                                                           | texts
      ${'state'}      | ${['detected', 'confirmed', 'resolved', 'dismissed']}                                            | ${VULNERABILITY_STATES}
      ${'severity'}   | ${['critical', 'high', 'medium', 'low', 'unknown', 'info']}                                      | ${SEVERITY_LEVELS}
      ${'reportType'} | ${['sast', 'dast', 'api_fuzzing', 'container_scanning', 'coverage_fuzzing', 'secret_detection']} | ${REPORT_TYPES_WITH_MANUALLY_ADDED}
    `('when group "$group" is selected', ({ group, values, texts }) => {
      beforeEach(async () => {
        await createWrapperWithFilters();
        selectGroupByItem(group);
      });

      it.each(values)('displays severity counts for "%s"', async (value) => {
        await createWrapperWithFilters({});
        await selectGroupByItem(group);

        const highlights = findSummaryHighlights(value);

        expect(highlights.props('showSingleSeverity')).toEqual(group === 'severity' ? value : '');
        expect(highlights.props('highlights')).toEqual({
          ...counts,
          __typename: 'VulnerabilitySeveritiesCount',
        });
      });

      it.each(values)(
        'updates the query string to persist the state accross page refresh for value "%s"',
        async (value) => {
          await createWrapperWithFilters({});
          await selectGroupByItem(group);

          expect(router.currentRoute.query.groupBy).toBe(group);
          expect(router.currentRoute.query.expanded).toBeUndefined();

          findGroupHeader(value).findComponent(GlLink).vm.$emit('click');
          await nextTick();

          expect(router.currentRoute.query.groupBy).toBe(group);
          expect(router.currentRoute.query.expanded).toBe(value);
        },
      );

      it.each(values)('displays the group header for value "%s"', (value) => {
        expect(findGroupHeader(value).exists()).toBe(true);
      });

      it.each(values)('displays the correct options for value "%s"', (value) => {
        expect(findGroupHeaderLink(value).text()).toBe(texts[value]);
      });

      it.each(values)('defaults to a collapsed state for value "%s"', (value) => {
        const groupHeader = findGroupHeader(value);
        const groupChevron = groupHeader.findComponent(GlIcon);
        expect(groupChevron.props('name')).toBe('chevron-right');
        expect(groupChevron.attributes('class')).not.toContain('gl-rotate-90');
      });

      it('expands when clicked on a group header and displays the vulnerability list', async () => {
        expect(findList().exists()).toBe(false);

        const groupHeader = findGroupHeader(values[0]);
        const groupChevron = groupHeader.findComponent(GlIcon);

        await groupHeader.findComponent(GlLink).vm.$emit('click');

        expect(groupChevron.props('name')).toBe('chevron-right');
        expect(groupChevron.attributes('class')).toContain('gl-rotate-90');
        expect(findList().exists()).toBe(true);
      });
    });

    describe.each`
      group         | values                                                      | filters
      ${'state'}    | ${['detected', 'confirmed', 'resolved', 'dismissed']}       | ${['CONFIRMED']}
      ${'severity'} | ${['critical', 'high', 'medium', 'low', 'unknown', 'info']} | ${['HIGH', 'MEDIUM']}
    `('when group "$group" is selected and filters are applied', ({ group, values, filters }) => {
      beforeEach(async () => {
        await createWrapperWithFilters({ filters: { [group]: filters } });
        selectGroupByItem(group);
      });

      it.each(filters.map((v) => v.toLowerCase()))(
        'displays the group header for value "%s"',
        (value) => {
          expect(findGroupHeader(value).exists()).toBe(true);
        },
      );

      it.each(values.filter((v) => !filters.includes(v.toUpperCase())))(
        'does not display the group header for value "%s"',
        (value) => {
          expect(findGroupHeader(value).exists()).toBe(false);
        },
      );
    });
  });

  describe('with group level vulnerability report grouping feature flag disabled', () => {
    beforeEach(() => {
      createWrapper({
        isVisible: true,
        isGroupVulnerabilityReport: true,
        isProjectVulnerabilityReport: false,
        glFeatures: {
          groupLevelVulnerabilityReportGrouping: false,
        },
      });
    });

    it('should not show the group by dropdown', () => {
      expect(findGroupByButton().exists()).toBe(false);
    });
  });
});
