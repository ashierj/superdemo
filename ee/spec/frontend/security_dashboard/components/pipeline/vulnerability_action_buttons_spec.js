import Vue from 'vue';
// eslint-disable-next-line no-restricted-imports
import Vuex from 'vuex';
import VueApollo from 'vue-apollo';
import { GlButton } from '@gitlab/ui';
import { createWrapper } from '@vue/test-utils';
import createMockApollo from 'helpers/mock_apollo_helper';
import VulnerabilityActionButtons, {
  i18n,
} from 'ee/security_dashboard/components/pipeline/vulnerability_action_buttons.vue';
import { setupStore } from 'ee/security_dashboard/store';
import { VULNERABILITY_MODAL_ID } from 'ee/vue_shared/security_reports/components/constants';
import { mountExtended, shallowMountExtended } from 'helpers/vue_test_utils_helper';
import waitForPromises from 'helpers/wait_for_promises';
import { BV_SHOW_MODAL } from '~/lib/utils/constants';
import { visitUrl } from '~/lib/utils/url_utility';
import {
  getPipelineSecurityReportFindingResponse,
  getVulnerabilityExternalIssuesQueryResponse,
} from 'ee_jest/security_dashboard/components/pipeline/mock_data';
import { vulnerabilityExternalIssueLinkCreateMockFactory } from 'ee_jest/vue_shared/security_reports/components/apollo_mocks';
import securityReportFindingQuery from 'ee/security_dashboard/graphql/queries/security_report_finding.query.graphql';
import vulnerabilityExternalIssuesQuery from 'ee/security_dashboard/graphql/queries/vulnerability_external_issues.query.graphql';
import createJiraIssueMutation from 'ee/security_dashboard/graphql/mutations/finding_create_jira_issue.mutation.graphql';
import { resetStore } from '../../helpers';
import mockDataVulnerabilities from '../../store/modules/vulnerabilities/data/mock_data_vulnerabilities';

Vue.use(Vuex);
Vue.use(VueApollo);

jest.mock('~/lib/utils/url_utility', () => ({
  visitUrl: jest.fn(),
}));

describe('Security Dashboard Action Buttons', () => {
  let store;
  let wrapper;
  let dispatchMock;
  let mockApollo;

  const wrapperFactory = (mountFn) => ({ ...options }) => {
    mockApollo = createMockApollo([
      [
        securityReportFindingQuery,
        jest.fn().mockResolvedValue(getPipelineSecurityReportFindingResponse()),
      ],
      [
        createJiraIssueMutation,
        options.handlers?.createJiraIssueMutation ||
          jest.fn().mockResolvedValue(vulnerabilityExternalIssueLinkCreateMockFactory()),
      ],
      [
        vulnerabilityExternalIssuesQuery,
        jest.fn().mockResolvedValue(getVulnerabilityExternalIssuesQueryResponse()),
      ],
    ]);

    wrapper = mountFn(VulnerabilityActionButtons, {
      ...options,
      store,
      apolloProvider: mockApollo,
      provide: {
        projectFullPath: 'group/project',
        pipeline: {
          iid: 22,
        },
      },
    });

    dispatchMock = jest.spyOn(store, 'dispatch').mockReturnValue(Promise.resolve());
  };

  const createShallowComponent = wrapperFactory(shallowMountExtended);
  const createFullComponent = wrapperFactory(mountExtended);

  const findAllButtons = () => wrapper.findAllComponents(GlButton);
  const findMoreInfoButton = () => wrapper.findByTestId('more-info');
  const findCreateIssueButton = () => wrapper.findByTestId('create-issue');
  const findDismissVulnerabilityButton = () => wrapper.findByTestId('dismiss-vulnerability');
  const findUndoDismissButton = () => wrapper.findByTestId('undo-dismiss');

  beforeEach(() => {
    store = new Vuex.Store();
    setupStore(store);
  });

  afterEach(() => {
    resetStore(store);
  });

  describe('with a fresh vulnerability', () => {
    beforeEach(() => {
      createFullComponent({
        propsData: {
          vulnerability: mockDataVulnerabilities[0],
          canCreateIssue: true,
          canDismissVulnerability: true,
        },
      });
    });

    it('should render three buttons in a button group', () => {
      expect(findAllButtons()).toHaveLength(3);
    });

    describe('More Info Button', () => {
      it('should render the More info button', () => {
        expect(findMoreInfoButton().exists()).toBe(true);
      });

      it('should render the correct tooltip', () => {
        expect(findMoreInfoButton().attributes('title')).toBe(i18n.moreInfo);
      });

      it('should emit an `setModalData` event and open the modal when clicked', async () => {
        await findMoreInfoButton().trigger('click');

        expect(dispatchMock).toHaveBeenCalledWith('vulnerabilities/setModalData', {
          vulnerability: mockDataVulnerabilities[0],
        });

        expect(createWrapper(wrapper.vm.$root).emitted(BV_SHOW_MODAL)).toEqual([
          [VULNERABILITY_MODAL_ID],
        ]);
      });
    });

    describe('Create Issue Button', () => {
      it('should render the create issue button', () => {
        expect(findCreateIssueButton().exists()).toBe(true);
      });

      it('should render the correct tooltip', () => {
        expect(findCreateIssueButton().attributes('title')).toBe(i18n.createIssue);
      });

      it('should emit an `createIssue` event when clicked', async () => {
        await findCreateIssueButton().trigger('click');

        expect(dispatchMock).toHaveBeenCalledWith('vulnerabilities/createIssue', {
          vulnerability: mockDataVulnerabilities[0],
          flashError: true,
        });
      });

      describe('with Jira issues for vulnerabilities enabled', () => {
        const propsData = {
          vulnerability: mockDataVulnerabilities[8],
          canCreateIssue: true,
        };

        it('should render the correct tooltip', () => {
          createFullComponent({ propsData });

          expect(findCreateIssueButton().attributes('title')).toBe(i18n.createJiraIssue);
        });

        it('should open a new window when the create-issue button is clicked', async () => {
          createFullComponent({ propsData });

          const createdJiraIssue = getVulnerabilityExternalIssuesQueryResponse().data.vulnerability
            .externalIssueLinks.nodes[0].externalIssue;

          expect(visitUrl).not.toHaveBeenCalled();

          await findCreateIssueButton().trigger('click');
          // Vuex handles the loading state
          expect(dispatchMock).toHaveBeenCalledWith(
            'vulnerabilities/createJiraIssueStart',
            undefined,
          );
          await waitForPromises();

          expect(visitUrl).toHaveBeenCalledWith(
            createdJiraIssue.webUrl,
            true, // external link flag
          );

          // Vuex handles the success state, as we need to disable the loading state and add the new data to the store
          expect(dispatchMock).toHaveBeenCalledWith('vulnerabilities/createJiraIssueSuccess', {
            externalIssue: {
              external_tracker: 'jira',
              web_url: createdJiraIssue.webUrl,
              references: {
                relative: createdJiraIssue.relativeReference,
              },
            },
            vulnerability: mockDataVulnerabilities[8],
          });
        });

        it('should show an error message when the mutation fails', async () => {
          createFullComponent({
            propsData,
            handlers: {
              createJiraIssueMutation: jest.fn().mockRejectedValue(),
            },
          });

          await findCreateIssueButton().trigger('click');
          await waitForPromises();

          expect(dispatchMock).toHaveBeenCalledWith(
            'vulnerabilities/receiveCreateIssueError',
            undefined,
          );
        });
      });
    });

    describe('Dismiss Vulnerability Button', () => {
      it('should render the dismiss vulnerability button', () => {
        expect(findDismissVulnerabilityButton().exists()).toBe(true);
      });

      it('should render the correct tooltip', () => {
        expect(findDismissVulnerabilityButton().attributes('title')).toBe(
          i18n.dismissVulnerability,
        );
      });

      it('should emit an `dismissVulnerability` event when clicked', async () => {
        await findDismissVulnerabilityButton().trigger('click');

        expect(dispatchMock).toHaveBeenCalledWith('vulnerabilities/dismissVulnerability', {
          vulnerability: mockDataVulnerabilities[0],
          flashError: true,
        });
      });
    });
  });

  describe('with a vulnerability that has an issue', () => {
    beforeEach(() => {
      createShallowComponent({
        propsData: {
          vulnerability: mockDataVulnerabilities[3],
        },
      });
    });

    it('should only render one button', () => {
      expect(findAllButtons()).toHaveLength(1);
    });

    it('should not render the create issue button', () => {
      expect(findCreateIssueButton().exists()).toBe(false);
    });
  });

  describe('with a vulnerability that has been dismissed', () => {
    beforeEach(() => {
      createShallowComponent({
        propsData: {
          vulnerability: mockDataVulnerabilities[2],
          canDismissVulnerability: true,
          isDismissed: true,
        },
      });
    });

    it('should render two buttons in a button group', () => {
      expect(findAllButtons()).toHaveLength(2);
    });

    it('should not render the dismiss vulnerability button', () => {
      expect(findDismissVulnerabilityButton().exists()).toBe(false);
    });

    it('should render the undo dismiss button', () => {
      expect(findUndoDismissButton().exists()).toBe(true);
    });

    it('should render the correct tooltip', () => {
      expect(findUndoDismissButton().attributes('title')).toBe(i18n.revertDismissVulnerability);
    });
  });
});
